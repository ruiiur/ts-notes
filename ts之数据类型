一.es5的数据类型有：
number， string， boolean，null， undefined，Object（Function， Array）
注意 用typeof可以检测出变量的基本数据类型，但是有个特例，就是null的typeof返回的是object，这个是javascript的历史Bug

二.es6的数据类型有：
number， string， boolean，null， undefined，Symbol, Object（Function， Array）

es6中新增 Symbol ，代表独一无二的值
创建一个 Symbol 类型的值：
let a = Symbol();
console.log(typeof a);  // "symbol"
注意： 通过 Symbol 方法创建值的时候不用使用 new 操作符，原因是通过 new 实例化的结果是一个 object 对象，而不是基本类型的 symbol
Symbol 方法接收一个参数，表示对生成的 symbol 值的一种描述, 如：let a = Symbol('f');
注意：即使是传入相同的参数，生成的 symbol 值也是不相等的，因为 Symbol 本来就是独一无二的意思
     const foo = Symbol('foo');
     const bar = Symbol('foo');
     console.log(foo === bar); // false
Symbol.for 方法可以检测上下文中是否已经存在使用该方法且相同参数创建的 symbol 值，如果存在则返回已经存在的值，如果不存在则新建
     const foo = Symbol('foo');
     const bar = Symbol('foo');
     console.log(foo === bar); // true
Symbol.keyFor 方法返回一个使用 Symbol.for 方法创建的 symbol 值的 key
    const foo = Symbol.for("fff");
    const key = Symbol.keyFor(foo);
    console.log(key) // "fff"

Symbol 的使用场景：
1.作为对象属性 当一个复杂对象中含有多个属性的时候，很容易将某个属性名覆盖掉，利用 Symbol 值作为属性名可以很好的避免这一现象。
    let name = Symbol('name');
    let obj = {
      [name]: 'du'
    }
2.es6的class没有 private 关键字来声明类的私有方法和私有变量的，但是我们可以利用 Symbol 的唯一性来模拟，因为使用者无法在外部创建出一个相同的 speak，所以就无法调用该方法


三.ts的数据类型有
1.number
  let a:number = 12;
2.string
  let a:string = '12';
3.boolean
  let a:boolean = true;
4.数组类型Array（有以下两种方式定义， 数组里面每个元素都是相同的类型）
 ------let arr:number[] = [1,2,3];
 ------let arr:Array<number> = [1,2,3]  数组泛型
5.元组tuple（数组的一种，元素类型与元素位置相对应）
 ------let arr:[number, string] = [1,'1']
6.枚举enum
  enum Color {
   red = 1, green, yellow
  }
  let c:Color = Color.green // 2
  // 如果标识符没有值，那么值就是下标
  // 如果从中间某个值开始赋值，其后面的元素值递加，前面的元素还是下标
      enum Color {
        red, green = 5, yellow
      }
      let c:Color = Color.yellow // 6
      let r:Color = Color.red // 0
7.null
8.undefined
  let num1: number | null | undefined;
  ---null 和 undefined 可以使用组合类型
9.any （任意类型）
  let a: any = 1;
  a = false;
  a.length; // 因为类型是 any ， 不会有任何判断，所以这里并不会报错
10. unknown (相当于严格意义上的any）
    因为 any 类型的熟悉可以随意调用属性和方法，很不安全。这时候可以用 unknown，unknown 中不能随意调用属性和方法，如果要调用，可以用类型断言，例如：
     let a: unknown = 1;
     a = false;
     a.length; // 因为类型是 unknown ， 不可以随意调用属性和方法，所以这里会报错
     可以改成：
     (a as string).length // 类型断言
     也可以使用类型保护：
     if (type a === 'string') {}
11.void
   函数没有返回值时，定义成void
12.never
   never类型表示的是那些永不存在的值的类型
   // 返回never的函数必须存在无法达到的终点
    function error(message: string): never {
      throw new Error(message);
    }
13.Object 对象




